<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>八字择吉任务推荐</title>
  <style>
    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      color: #555;
      font-size: 1.1em;
    }
    
    input, select, button {
      padding: 12px;
      font-size: 16px;
      width: 100%;
      max-width: 400px;
      border: 2px solid #ddd;
      border-radius: 8px;
      transition: all 0.3s ease;
    }
    
    input:focus, select:focus {
      border-color: #667eea;
      outline: none;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
    }
    
    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2em;
      margin-top: 20px;
      transition: transform 0.2s ease;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    #result {
      margin-top: 30px;
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.8;
      background: #f8f9fa;
      padding: 25px;
      border-radius: 10px;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
      border-left: 5px solid #667eea;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
      max-height: 600px;
      overflow-y: auto;
    }
    
    .loading {
      text-align: center;
      color: #667eea;
      font-size: 1.2em;
    }
    
    .error {
      color: #e74c3c;
      background: #fdf2f2;
      border-left-color: #e74c3c;
    }
    
    .success {
      color: #27ae60;
    }
    
    .highlight {
      background: #fff3cd;
      padding: 2px 4px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🔮 Academic god</h1>

    <div class="form-group">
      <label for="birth">📅 出生日期时间</label>
      <input type="datetime-local" id="birth" />
    </div>

    <div class="form-group">
      <label for="gender">👤 性别</label>
      <select id="gender">
        <option value="1">男</option>
        <option value="0">女</option>
      </select>
    </div>

    <div class="form-group">
      <label for="task">📝 任务类型</label>
      <select id="task">
        <option value="投稿">📄 投稿</option>
        <option value="返修">✏️ 返修</option>
        <option value="盲审">👁️ 盲审</option>
        <option value="答辩">🎓 答辩</option>
      </select>
    </div>

    <div class="form-group">
      <label for="days">📊 分析天数（1-365天）</label>
      <input type="number" id="days" min="1" max="365" value="30" />
    </div>

    <button onclick="submitForm()">🚀 开始分析</button>

    <div id="result"></div>
  </div>

  <script>
    // ==================== 八字计算核心算法 ====================
    
    // 天干地支数据
    const TIANGAN = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];
    const DIZHI = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
    
    // 天干五行映射
    const GAN_WUXING = {
      "甲": "木", "乙": "木", "丙": "火", "丁": "火", "戊": "土", "己": "土",
      "庚": "金", "辛": "金", "壬": "水", "癸": "水"
    };
    
    // 地支五行映射
    const ZHI_WUXING = {
      "子": "水", "丑": "土", "寅": "木", "卯": "木",
      "辰": "土", "巳": "火", "午": "火", "未": "土",
      "申": "金", "酉": "金", "戌": "土", "亥": "水"
    };
    
    // 地支藏干映射
    const ZHI_CANGGAN = {
      "子": ["癸"], "丑": ["己", "癸", "辛"], "寅": ["甲", "丙", "戊"], "卯": ["乙"],
      "辰": ["戊", "乙", "癸"], "巳": ["丙", "庚", "戊"], "午": ["丁", "己"],
      "未": ["己", "丁", "乙"], "申": ["庚", "壬", "戊"], "酉": ["辛"],
      "戌": ["戊", "辛", "丁"], "亥": ["壬", "甲"]
    };
    
    // 纳音表
    const NAYIN_TABLE = {
      "甲子": "海中金", "乙丑": "海中金", "丙寅": "炉中火", "丁卯": "炉中火",
      "戊辰": "大林木", "己巳": "大林木", "庚午": "路旁土", "辛未": "路旁土",
      "壬申": "剑锋金", "癸酉": "剑锋金", "甲戌": "山头火", "乙亥": "山头火",
      "丙子": "涧下水", "丁丑": "涧下水", "戊寅": "城头土", "己卯": "城头土",
      "庚辰": "白蜡金", "辛巳": "白蜡金", "壬午": "杨柳木", "癸未": "杨柳木",
      "甲申": "泉中水", "乙酉": "泉中水", "丙戌": "屋上土", "丁亥": "屋上土",
      "戊子": "霹雳火", "己丑": "霹雳火", "庚寅": "松柏木", "辛卯": "松柏木",
      "壬辰": "长流水", "癸巳": "长流水", "甲午": "砂中金", "乙未": "砂中金",
      "丙申": "山下火", "丁酉": "山下火", "戊戌": "平地木", "己亥": "平地木",
      "庚子": "壁上土", "辛丑": "壁上土", "壬寅": "金箔金", "癸卯": "金箔金",
      "甲辰": "覆灯火", "乙巳": "覆灯火", "丙午": "天河水", "丁未": "天河水",
      "戊申": "大驿土", "己酉": "大驿土", "庚戌": "钗钏金", "辛亥": "钗钏金",
      "壬子": "桑柘木", "癸丑": "桑柘木", "甲寅": "大溪水", "乙卯": "大溪水",
      "丙辰": "沙中土", "丁巳": "沙中土", "戊午": "天上火", "己未": "天上火",
      "庚申": "石榴木", "辛酉": "石榴木", "壬戌": "大海水", "癸亥": "大海水"
    };
    
    // 天干阴阳
    const GAN_YINYANG = {
      "甲": "阳", "乙": "阴", "丙": "阳", "丁": "阴", "戊": "阳", "己": "阴",
      "庚": "阳", "辛": "阴", "壬": "阳", "癸": "阴"
    };
    
    // 五行生克关系
    const SHENG_MAP = {"木": "火", "火": "土", "土": "金", "金": "水", "水": "木"};
    const KE_MAP = {"木": "土", "火": "金", "土": "水", "金": "木", "水": "火"};
    const SHENG_WO = Object.fromEntries(Object.entries(SHENG_MAP).map(([k, v]) => [v, k]));
    const KE_WO = Object.fromEntries(Object.entries(KE_MAP).map(([k, v]) => [v, k]));
    
    // 运势解释
    const YUNSHI_JIESHI = {
      "比肩": "自我强化之运，适合独立创业、自主决策",
      "劫财": "竞争压力之运，需注意合作关系与财务风险",
      "食神": "安逸享乐之运，适合创意表达、学术成长",
      "伤官": "才华释放之运，利于展示能力，需注意得罪权威",
      "正财": "稳健求财之运，适合投资理财、积累财富",
      "偏财": "偏门之财之运，适合接触机会型项目或跨界收益",
      "正官": "规范成长之运，适合晋升考试、公务申报等",
      "七杀": "压力挑战之运，利于突破瓶颈、展现领导力",
      "正印": "学习积累之运，利于深造、提升学历与资历",
      "偏印": "灵感与内省之运，适合研究、写作、静心修炼"
    };
    
    // 学术/事业星含义
    const CAREER_STAR_MEANING = {
      "食神": "适合创作、写作、享受学术带来的成果",
      "伤官": "利于发表、辩论、展示才华，需注意言辞锋芒",
      "正印": "利于学习考试、取得资质、师承、学位",
      "七杀": "适合突破压力挑战，有望脱颖而出"
    };
    
    // 神煞数据
    const TASK_YI_JISHEN = {
      "投稿": new Set(["文昌", "天乙", "学堂", "玉堂", "金匮", "月恩", "天德", "青龙"]),
      "返修": new Set(["天德", "月德", "六合", "解神", "时德", "时阳", "天赦", "玉堂"]),
      "盲审": new Set(["金匮", "天乙", "青龙", "明堂", "天恩", "天喜", "福生", "王日"]),
      "答辩": new Set(["文昌", "三奇", "天喜", "金匮", "玉堂", "天医", "天赦", "明堂", "天德合"])
    };
    
    const TASK_JI_XIONGSHA = {
      "投稿": new Set(["天贼", "披麻", "破日", "死神", "小耗", "月煞", "劫煞", "血忌"]),
      "返修": new Set(["月破", "日破", "旬空", "天贼", "复日", "死气", "月厌", "月害"]),
      "盲审": new Set(["披麻", "劫煞", "月煞", "死气", "五鬼", "天狗", "白虎"]),
      "答辩": new Set(["天贼", "死气", "五鬼", "月厌", "朱雀", "地火", "白虎", "孤阳"])
    };
    
    // ==================== 农历转换算法 ====================
    
    // 简化的农历数据（1900-2100年）
    const LUNAR_INFO = [
      0x04bd8, 0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950, 0x16554, 0x056a0, 0x09ad0, 0x055d2,
      0x04ae0, 0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540, 0x0d6a0, 0x0ada2, 0x095b0, 0x14977,
      0x04970, 0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54, 0x02b60, 0x09570, 0x052f2, 0x04970,
      0x06566, 0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60, 0x186e3, 0x092e0, 0x1c8d7, 0x0c950,
      0x0d4a0, 0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0, 0x092d0, 0x0d2b2, 0x0a950, 0x0b557,
      0x06ca0, 0x0b550, 0x15355, 0x04da0, 0x0a5b0, 0x14573, 0x052b0, 0x0a9a8, 0x0e950, 0x06aa0,
      0x0aea6, 0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260, 0x0f263, 0x0d950, 0x05b57, 0x056a0,
      0x096d0, 0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250, 0x0d558, 0x0b540, 0x0b6a0, 0x195a6,
      0x095b0, 0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50, 0x06d40, 0x0af46, 0x0ab60, 0x09570,
      0x04af5, 0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58, 0x055c0, 0x0ab60, 0x096d5, 0x092e0,
      0x0c960, 0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0, 0x0abb7, 0x025d0, 0x092d0, 0x0cab5,
      0x0a950, 0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0, 0x0a5b0, 0x15176, 0x052b0, 0x0a930,
      0x07954, 0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6, 0x0a4e0, 0x0d260, 0x0ea65, 0x0d530,
      0x05aa0, 0x076a3, 0x096d0, 0x04afb, 0x04ad0, 0x0a4d0, 0x1d0b6, 0x0d250, 0x0d520, 0x0dd45,
      0x0b5a0, 0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0, 0x0aa50, 0x1b255, 0x06d20, 0x0ada0,
      0x14b63, 0x09370, 0x049f8, 0x04970, 0x064b0, 0x168a6, 0x0ea50, 0x06b20, 0x1a6c4, 0x0aae0,
      0x0a2e0, 0x0d2e3, 0x0c960, 0x0d557, 0x0d4a0, 0x0da50, 0x05d55, 0x056a0, 0x0a6d0, 0x055d4,
      0x052d0, 0x0a9b8, 0x0a950, 0x0b4a0, 0x0b6a6, 0x0ad50, 0x055a0, 0x0aba4, 0x0a5b0, 0x052b0,
      0x0b273, 0x06930, 0x07337, 0x06aa0, 0x0ad50, 0x14b55, 0x04b60, 0x0a570, 0x054e4, 0x0d160,
      0x0e968, 0x0d520, 0x0daa0, 0x16aa6, 0x056d0, 0x04ae0, 0x0a9d4, 0x0a2d0, 0x0d150, 0x0f252,
      0x0d520
    ];
    
    // 计算农历年天数
    function lunarYearDays(year) {
      let sum = 348;
      for (let i = 0x8000; i > 0x8; i >>= 1) {
        sum += (LUNAR_INFO[year - 1900] & i) ? 1 : 0;
      }
      return sum + leapDays(year);
    }
    
    // 计算农历年闰月天数
    function leapDays(year) {
      if (leapMonth(year)) {
        return (LUNAR_INFO[year - 1900] & 0x10000) ? 30 : 29;
      }
      return 0;
    }
    
    // 计算农历年闰月
    function leapMonth(year) {
      return LUNAR_INFO[year - 1900] & 0xf;
    }
    
    // 计算农历月天数
    function monthDays(year, month) {
      return (LUNAR_INFO[year - 1900] & (0x10000 >> month)) ? 30 : 29;
    }
    
    // 公历转农历
    function solarToLunar(date) {
      const baseDate = new Date(1900, 0, 31);
      const offset = Math.floor((date - baseDate) / 86400000);
      
      let lunarYear = 1900;
      let temp = 0;
      
      while (lunarYear < 2100 && offset > temp) {
        temp += lunarYearDays(lunarYear);
        lunarYear++;
      }
      
      if (offset < temp) {
        temp -= lunarYearDays(lunarYear - 1);
        lunarYear--;
      }
      
      let lunarMonth = 1;
      let leap = leapMonth(lunarYear);
      let isLeap = false;
      
      while (lunarMonth < 13 && offset > temp) {
        if (leap > 0 && lunarMonth === (leap + 1) && !isLeap) {
          lunarMonth--;
          isLeap = true;
          temp += leapDays(lunarYear);
        } else {
          temp += monthDays(lunarYear, lunarMonth);
        }
        
        if (isLeap && lunarMonth === (leap + 1)) {
          isLeap = false;
        }
        lunarMonth++;
      }
      
      if (offset < temp) {
        lunarMonth--;
        temp -= isLeap ? leapDays(lunarYear) : monthDays(lunarYear, lunarMonth);
      }
      
      const lunarDay = offset - temp + 1;
      
      return {
        year: lunarYear,
        month: lunarMonth,
        day: lunarDay,
        isLeap: isLeap
      };
    }
    
    // ==================== 八字计算函数 ====================
    
    // 计算干支
    function getGanZhi(num) {
      const gan = TIANGAN[num % 10];
      const zhi = DIZHI[num % 12];
      return gan + zhi;
    }
    
    // 计算年柱
    function getYearGanZhi(year) {
      return getGanZhi(year - 4);
    }
    
    // 计算月柱
    function getMonthGanZhi(year, month) {
      const yearGan = TIANGAN[(year - 4) % 10];
      const yearGanIndex = TIANGAN.indexOf(yearGan);
      
      // 月干计算公式
      const monthGanIndex = (yearGanIndex * 2 + month) % 10;
      const monthGan = TIANGAN[monthGanIndex];
      const monthZhi = DIZHI[(month + 1) % 12];
      
      return monthGan + monthZhi;
    }
    
    // 计算日柱
    function getDayGanZhi(date) {
      const baseDate = new Date(1900, 0, 1);
      const days = Math.floor((date - baseDate) / 86400000);
      return getGanZhi(days + 10);
    }
    
    // 计算时柱
    function getTimeGanZhi(date, dayGanZhi) {
      const hour = date.getHours();
      let timeZhiIndex;
      
      if (hour >= 23 || hour < 1) timeZhiIndex = 0; // 子时
      else if (hour < 3) timeZhiIndex = 1; // 丑时
      else if (hour < 5) timeZhiIndex = 2; // 寅时
      else if (hour < 7) timeZhiIndex = 3; // 卯时
      else if (hour < 9) timeZhiIndex = 4; // 辰时
      else if (hour < 11) timeZhiIndex = 5; // 巳时
      else if (hour < 13) timeZhiIndex = 6; // 午时
      else if (hour < 15) timeZhiIndex = 7; // 未时
      else if (hour < 17) timeZhiIndex = 8; // 申时
      else if (hour < 19) timeZhiIndex = 9; // 酉时
      else if (hour < 21) timeZhiIndex = 10; // 戌时
      else timeZhiIndex = 11; // 亥时
      
      const dayGan = dayGanZhi[0];
      const dayGanIndex = TIANGAN.indexOf(dayGan);
      const timeGanIndex = (dayGanIndex * 2 + timeZhiIndex) % 10;
      
      return TIANGAN[timeGanIndex] + DIZHI[timeZhiIndex];
    }
    
    // 计算八字
    function calculateBaZi(date) {
      const lunar = solarToLunar(date);
      
      const yearGZ = getYearGanZhi(lunar.year);
      const monthGZ = getMonthGanZhi(lunar.year, lunar.month);
      const dayGZ = getDayGanZhi(date);
      const timeGZ = getTimeGanZhi(date, dayGZ);
      
      return {
        year: yearGZ,
        month: monthGZ,
        day: dayGZ,
        time: timeGZ,
        lunar: lunar
      };
    }
    
    // 计算纳音
    function getNaYin(ganZhi) {
      return NAYIN_TABLE[ganZhi] || "未知";
    }
    
    // 计算十神
    function getTenGod(dayGan, otherGan) {
      const dayWx = GAN_WUXING[dayGan];
      const otherWx = GAN_WUXING[otherGan];
      
      const tenGodMap = {
        "同五行阳阳或阴阴": "比肩",
        "同五行阴阳相异": "劫财",
        "我生者阳阳或阴阴": "食神",
        "我生者阴阳相异": "伤官",
        "生我者阳阳或阴阴": "正印",
        "生我者阴阳相异": "偏印",
        "我克者阳阳或阴阴": "正财",
        "我克者阴阳相异": "偏财",
        "克我者阳阳或阴阴": "正官",
        "克我者阴阳相异": "七杀"
      };
      
      let relation = "";
      if (otherWx === dayWx) {
        relation = "同五行";
      } else if (SHENG_MAP[dayWx] === otherWx) {
        relation = "我生者";
      } else if (SHENG_WO[dayWx] === otherWx) {
        relation = "生我者";
      } else if (KE_MAP[dayWx] === otherWx) {
        relation = "我克者";
      } else if (KE_WO[dayWx] === otherWx) {
        relation = "克我者";
      } else {
        relation = "其他";
      }
      
      const yyMatch = GAN_YINYANG[dayGan] === GAN_YINYANG[otherGan] ? "阳阳或阴阴" : "阴阳相异";
      return tenGodMap[relation + yyMatch] || "未知";
    }
    
    // 分析五行强弱
    function analyzeWuXingStrength(baZi) {
      const ganZhiList = [baZi.year, baZi.month, baZi.day, baZi.time];
      const wuxingCount = {"木": 0, "火": 0, "土": 0, "金": 0, "水": 0};
      
      // 统计天干
      ganZhiList.forEach(gz => {
        const gan = gz[0];
        if (GAN_WUXING[gan]) {
          wuxingCount[GAN_WUXING[gan]]++;
        }
      });
      
      // 统计藏干
      ganZhiList.forEach(gz => {
        const zhi = gz[1];
        if (ZHI_CANGGAN[zhi]) {
          ZHI_CANGGAN[zhi].forEach(gan => {
            if (GAN_WUXING[gan]) {
              wuxingCount[GAN_WUXING[gan]]++;
            }
          });
        }
      });
      
      const dayGan = baZi.day[0];
      const dayWuxing = GAN_WUXING[dayGan];
      
      // 判断强弱：得令、得地、得助
      const monthZhi = baZi.month[1];
      const deLing = ZHI_CANGGAN[monthZhi] && ZHI_CANGGAN[monthZhi].includes(dayGan);
      
      const otherZhi = [baZi.year[1], baZi.time[1]];
      const deDi = otherZhi.some(zhi => 
        ZHI_CANGGAN[zhi] && (
          ZHI_CANGGAN[zhi].includes(dayGan) ||
          ZHI_CANGGAN[zhi].some(gan => GAN_WUXING[gan] === SHENG_WO[dayWuxing])
        )
      );
      
      const otherGan = [baZi.year[0], baZi.month[0], baZi.time[0]];
      const deZhu = otherGan.some(gan => 
        GAN_WUXING[gan] === dayWuxing || GAN_WUXING[gan] === SHENG_WO[dayWuxing]
      );
      
      // 强弱判断得分机制（0~3）
      const strengthScore = [deLing, deDi, deZhu].filter(Boolean).length;
      let status;
      if (strengthScore >= 2) {
        status = "日主偏强";
      } else if (strengthScore === 1) {
        status = "中和";
      } else {
        status = "日主偏弱";
      }
      
      // 用神与忌神判断
      let yongShen, jiShen, xiShen;
      if (status === "日主偏强") {
        yongShen = [SHENG_MAP[dayWuxing], KE_MAP[dayWuxing]];
        jiShen = [dayWuxing, SHENG_WO[dayWuxing]];
        xiShen = ["--"];
      } else if (status === "日主偏弱") {
        yongShen = [dayWuxing, SHENG_WO[dayWuxing]];
        jiShen = [KE_MAP[dayWuxing], SHENG_MAP[dayWuxing]];
        xiShen = ["--"];
      } else {
        // 中和格局
        const sortedWuxing = Object.entries(wuxingCount).sort((a, b) => a[1] - b[1]);
        xiShen = [sortedWuxing[0][0]];
        jiShen = [sortedWuxing[sortedWuxing.length - 1][0]];
        yongShen = ["中庸调和"];
      }
      
      return {
        dayGan,
        dayWuxing,
        status,
        wuxingCount,
        yongShen,
        xiShen,
        jiShen,
        deLing,
        deDi,
        deZhu
      };
    }
    
    // 计算大运
    function calculateDaYun(baZi, gender, currentYear) {
      const dayun = [];
      const birthYear = baZi.lunar.year;
      
      // 简化的大运计算
      for (let i = 0; i < 8; i++) {
        const startAge = i * 10 + 1;
        const endAge = (i + 1) * 10;
        const startYear = birthYear + startAge;
        const endYear = birthYear + endAge;
        
        // 简化的大运干支计算
        const ganIndex = (TIANGAN.indexOf(baZi.month[0]) + i + (gender === 1 ? 1 : -1)) % 10;
        const zhiIndex = (DIZHI.indexOf(baZi.month[1]) + i + (gender === 1 ? 1 : -1)) % 12;
        const ganzhi = TIANGAN[ganIndex < 0 ? ganIndex + 10 : ganIndex] + 
                      DIZHI[zhiIndex < 0 ? zhiIndex + 12 : zhiIndex];
        
        dayun.push({
          index: i + 1,
          startAge,
          endAge,
          startYear,
          endYear,
          ganzhi
        });
      }
      
      return dayun;
    }
    
    // 计算当前年龄
    function calculateAge(birthDate, currentDate) {
      let age = currentDate.getFullYear() - birthDate.getFullYear();
      if ((currentDate.getMonth() < birthDate.getMonth()) || 
          (currentDate.getMonth() === birthDate.getMonth() && currentDate.getDate() < birthDate.getDate())) {
        age--;
      }
      return age;
    }
    
    // 简化的神煞计算
    function calculateShenSha(date, task) {
      // 简化版本，随机生成一些神煞用于演示
      const allJiShen = ["文昌", "天乙", "学堂", "玉堂", "金匮", "月恩", "天德", "青龙", "明堂", "天恩", "天喜", "福生", "王日"];
      const allXiongSha = ["天贼", "披麻", "破日", "死神", "小耗", "月煞", "劫煞", "血忌", "月破", "日破", "旬空", "复日", "死气", "月厌", "月害"];
      
      // 基于日期生成伪随机神煞
      const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
      const jiShenCount = (dayOfYear % 4) + 1;
      const xiongShaCount = (dayOfYear % 3) + 1;
      
      const jiShen = [];
      const xiongSha = [];
      
      for (let i = 0; i < jiShenCount; i++) {
        const index = (dayOfYear + i) % allJiShen.length;
        jiShen.push(allJiShen[index]);
      }
      
      for (let i = 0; i < xiongShaCount; i++) {
        const index = (dayOfYear + i + 7) % allXiongSha.length;
        xiongSha.push(allXiongSha[index]);
      }
      
      return { jiShen, xiongSha };
    }
    
    // 择吉评分算法
    function evaluateDayForTask(date, task, yongShen, jiShen, dayGan, daYunTenGod, liuNianTenGod, liuYueTenGod) {
      try {
        const baZi = calculateBaZi(date);
        const dayGanCurr = baZi.day[0];
        const dayZhiCurr = baZi.day[1];
        const dayGanWx = GAN_WUXING[dayGanCurr];
        const dayZhiWx = ZHI_WUXING[dayZhiCurr];
        
        const shenSha = calculateShenSha(date, task);
        const jiShenSet = new Set(shenSha.jiShen);
        const xiongShaSet = new Set(shenSha.xiongSha);
        
        let score = 0;
        
        // 神煞评分
        const taskYiJiShen = TASK_YI_JISHEN[task] || new Set();
        const taskJiXiongSha = TASK_JI_XIONGSHA[task] || new Set();
        
        score += Array.from(jiShenSet).filter(x => taskYiJiShen.has(x)).length * 1.5;
        score -= Array.from(xiongShaSet).filter(x => taskJiXiongSha.has(x)).length * 2;
        
        // 用神与忌神评分
        if (yongShen.includes(dayGanWx)) score += 2;
        if (yongShen.includes(dayZhiWx)) score += 1;
        if (jiShen.includes(dayGanWx)) score -= 2;
        if (jiShen.includes(dayZhiWx)) score -= 1;
        
        // 运势评分
        [daYunTenGod, liuNianTenGod, liuYueTenGod].forEach(tg => {
          if (["食神", "伤官", "正印", "七杀"].includes(tg)) {
            score += 1;
          }
        });
        
        return {
          date: date.toISOString().split('T')[0],
          ganzhi: dayGanCurr + dayZhiCurr,
          jiShen: Array.from(jiShenSet),
          xiongSha: Array.from(xiongShaSet),
          wuxing: `${dayGanWx}/${dayZhiWx}`,
          score: Math.round(score * 100) / 100
        };
      } catch (e) {
        return {
          date: date.toISOString().split('T')[0],
          ganzhi: "计算失败",
          jiShen: [],
          xiongSha: [],
          wuxing: "未知/未知",
          score: 0,
          error: e.message
        };
      }
    }
    
    // ==================== 主分析函数 ====================
    
    function runBaziAnalysis(birthDateTime, gender, task, days, currentTime) {
      const result = {
        prints: [],
        data: {}
      };
      
      try {
        // 计算八字
        const baZi = calculateBaZi(birthDateTime);
        const ganZhiList = [baZi.year, baZi.month, baZi.day, baZi.time];
        
        result.data.gan_zhi = ganZhiList;
        result.prints.push(`\n\n ✨ 八字分析结果 ✨\n干支列表: ${ganZhiList.join(' ')}`);
        
        // 纳音信息
        const nayin = {
          year: getNaYin(baZi.year),
          month: getNaYin(baZi.month),
          day: getNaYin(baZi.day),
          time: getNaYin(baZi.time)
        };
        result.data.nayin = nayin;
        result.prints.push(`纳音：年:${nayin.year},月:${nayin.month},日:${nayin.day},时:${nayin.time}`);
        
        // 十神信息
        const dayGan = baZi.day[0];
        const shishenGan = {
          year: getTenGod(dayGan, baZi.year[0]),
          month: getTenGod(dayGan, baZi.month[0]),
          day: getTenGod(dayGan, dayGan),
          time: getTenGod(dayGan, baZi.time[0])
        };
        result.data.shishen_gan = shishenGan;
        result.prints.push(`干十神：年:${shishenGan.year},月:${shishenGan.month},日:${shishenGan.day},时:${shishenGan.time}`);
        
        // 强弱分析
        const qiangruo = analyzeWuXingStrength(baZi);
        result.data.qiangruo = {
          日主: qiangruo.dayGan,
          五行: qiangruo.dayWuxing,
          日主强弱: qiangruo.status,
          五行分布: qiangruo.wuxingCount,
          用神: qiangruo.yongShen,
          喜神推荐: qiangruo.xiShen,
          忌神建议: qiangruo.jiShen
        };
        
        result.prints.push(`\n【日主】：${qiangruo.dayGan}（五行：${qiangruo.dayWuxing}）`);
        result.prints.push(`【日主强弱】：${qiangruo.status}（得令：${qiangruo.deLing}，得地：${qiangruo.deDi}，得助：${qiangruo.deZhu}）`);
        result.prints.push(`【五行分布】：${JSON.stringify(qiangruo.wuxingCount)}`);
        result.prints.push(`【用神推荐】：${qiangruo.yongShen.join(', ')}`);
        result.prints.push(`【喜神推荐】：${qiangruo.xiShen.join(', ')}`);
        result.prints.push(`【忌神建议】：${qiangruo.jiShen.join(', ')}`);
        
        // 大运分析
        const dayun = calculateDaYun(baZi, gender, currentTime.getFullYear());
        result.data.dayun = dayun;
        
        result.prints.push("\n大运：");
        dayun.forEach(d => {
          result.prints.push(`${d.startAge}岁-${d.endAge}岁：第${d.index}轮大运，${d.ganzhi}`);
        });
        
        // 当前年龄
        const age = calculateAge(birthDateTime, currentTime);
        result.data.current_age = age;
        result.prints.push(`当前年龄: ${age}岁`);
        
        // 当前大运
        const currentDayun = dayun.find(d => d.startYear <= currentTime.getFullYear() && currentTime.getFullYear() <= d.endYear);
        
        if (currentDayun) {
          result.data.current_dayun = {
            basic: {
              ganzhi: currentDayun.ganzhi,
              age_range: `${currentDayun.startAge}~${currentDayun.endAge}岁`
            }
          };
          
          result.prints.push(`\n🎯 当前所在大运：${currentDayun.ganzhi} (${currentDayun.startAge}~${currentDayun.endAge}岁)`);
          
          // 当前运势十神分析
          const currentBaZi = calculateBaZi(currentTime);
          const daYunGan = currentDayun.ganzhi[0];
          const liuNianGan = currentBaZi.year[0];
          const liuYueGan = currentBaZi.month[0];
          
          const daYunTenGod = getTenGod(dayGan, daYunGan);
          const liuNianTenGod = getTenGod(dayGan, liuNianGan);
          const liuYueTenGod = getTenGod(dayGan, liuYueGan);
          
          const interpretations = {
            dayun: `\n【当前大运】：${currentDayun.ganzhi}（十神：${daYunTenGod}）→ ${YUNSHI_JIESHI[daYunTenGod] || '无明确运势'}`,
            liunian: `【当前流年】：${currentBaZi.year}（十神：${liuNianTenGod}）→ ${YUNSHI_JIESHI[liuNianTenGod] || '无明确运势'}`,
            liuyue: `【当前流月】：${currentBaZi.month}（十神：${liuYueTenGod}）→ ${YUNSHI_JIESHI[liuYueTenGod] || '无明确运势'}`
          };
          
          result.data.current_dayun.interpretations = interpretations;
          result.prints.push(interpretations.dayun);
          result.prints.push(interpretations.liunian);
          result.prints.push(interpretations.liuyue);
          
          // 学术/事业星分析
          const careerStars = new Set(Object.keys(CAREER_STAR_MEANING));
          const activeStars = {
            "大运": daYunTenGod,
            "流年": liuNianTenGod,
            "流月": liuYueTenGod
          };
          
          const highlight = Object.fromEntries(
            Object.entries(activeStars).filter(([k, v]) => careerStars.has(v))
          );
          
          if (Object.keys(highlight).length > 0) {
            result.data.current_dayun.xingyao = [];
            Object.entries(highlight).forEach(([period, star]) => {
              const meaning = CAREER_STAR_MEANING[star];
              result.data.current_dayun.xingyao.push({
                period,
                star,
                meaning,
                period_explanation: `${period}运势影响`
              });
            });
          }
          
          // 择吉分析
          const startDay = new Date(currentTime);
          const allResults = [];
          
          for (let i = 0; i < days; i++) {
            const d = new Date(startDay);
            d.setDate(startDay.getDate() + i);
            const result1 = evaluateDayForTask(
              d, task, qiangruo.yongShen, qiangruo.jiShen, dayGan,
              daYunTenGod, liuNianTenGod, liuYueTenGod
            );
            allResults.push(result1);
          }
          
          // 推荐日处理
          let goodDays = allResults.filter(r => r.score >= 2);
          
          result.data.days = {
            task: task,
            recommend_days: [],
            highest_scores: []
          };
          
          let printsBuffer = [`\n📅 未来${days}天择吉推荐（任务：${task}）：`];
          
          if (goodDays.length === 0) {
            printsBuffer.push(`\n⚠️ 无得分 ≥ 2 的推荐日，推荐得分最高的前三日：`);
            goodDays = allResults.sort((a, b) => b.score - a.score).slice(0, 3);
            result.data.days.recommend_type = 'highest_scores';
            result.data.days.highest_scores = goodDays.map(d => d.score);
          } else {
            printsBuffer.push(`\n📅 找到 ${goodDays.length} 个推荐日：`);
            result.data.days.recommend_type = 'qualified';
          }
          
          goodDays.forEach((day, idx) => {
            printsBuffer.push(`\n🎯 推荐日${idx + 1}：${day.date} | 得分：${day.score}`);
            printsBuffer.push(`日干支：${day.ganzhi}，五行：${day.wuxing}`);
            printsBuffer.push(`吉神：${day.jiShen.join('、') || '无'}`);
            printsBuffer.push(`凶煞：${day.xiongSha.join('、') || '无'}`);
            
            result.data.days.recommend_days.push({
              ranking: idx + 1,
              date: day.date,
              score: day.score,
              ganzhi: day.ganzhi,
              wuxing: {
                gan: day.wuxing.split('/')[0],
                zhi: day.wuxing.split('/')[1]
              },
              auspicious: day.jiShen,
              inauspicious: day.xiongSha
            });
          });
          
          result.prints = printsBuffer.concat(result.prints);
        }
        
        return result;
        
      } catch (e) {
        result.prints.push(`分析过程中出现错误: ${e.message}`);
        return result;
      }
    }
    
    // ==================== 表单提交函数 ====================
    
    function submitForm() {
      const birth = document.getElementById('birth').value;
      const gender = parseInt(document.getElementById('gender').value);
      const task = document.getElementById('task').value;
      const days = parseInt(document.getElementById('days').value);

      // 输入验证
      if (!birth) {
        alert("⚠️ 请输入出生日期和时间！");
        return;
      }

      if (days < 1 || days > 365) {
        alert("⚠️ 分析天数必须在1-365之间！");
        return;
      }

      const resultBox = document.getElementById('result');
      resultBox.className = 'loading';
      resultBox.innerText = "⏳ 正在分析八字信息，请稍候...\n\n这可能需要几秒钟时间来计算您的命理信息和择吉推荐。";

      // 使用setTimeout模拟异步处理
      setTimeout(() => {
        try {
          const birthDateTime = new Date(birth);
          const currentTime = new Date();
          
          const analysisResult = runBaziAnalysis(birthDateTime, gender, task, days, currentTime);
          
          resultBox.className = 'success';
          
          // 格式化输出结果
          let formattedResult = "";
          formattedResult += "=".repeat(50) + "\n\n";
          
          analysisResult.prints.forEach(line => {
            if (line.includes('🎯') || line.includes('📅')) {
              formattedResult += "\n" + line + "\n";
            } else if (line.includes('【') && line.includes('】')) {
              formattedResult += "\n" + line + "\n";
            } else {
              formattedResult += line + "\n";
            }
          });
          
          resultBox.innerText = formattedResult;
          
          // 如果有学术/事业星曜
          if (analysisResult.data.current_dayun && analysisResult.data.current_dayun.xingyao && analysisResult.data.current_dayun.xingyao.length > 0) {
            const xingyaoList = analysisResult.data.current_dayun.xingyao;
            resultBox.innerText += "\n\n🎓 学术/事业星曜提示:\n";
            xingyaoList.forEach(x => {
              resultBox.innerText += `【${x.period}】出现金曜【${x.star}】：${x.meaning}\n`;
              resultBox.innerText += `说明：${x.period_explanation}\n`;
            });
          } else {
            resultBox.innerText += "\n\n⚠️ 当前阶段暂无对学术/事业有利的星曜提示\n";
          }
          
          // 添加数据摘要
          if (analysisResult.data.qiangruo) {
            const summary = analysisResult.data.qiangruo;
            resultBox.innerText += "\n\n📋 分析摘要:\n";
            resultBox.innerText += `日主: ${summary.日主} (${summary.五行})\n`;
            resultBox.innerText += `强弱: ${summary.日主强弱}\n`;
            resultBox.innerText += `用神: ${summary.用神.join(', ')}\n`;
            resultBox.innerText += `忌神: ${summary.忌神建议.join(', ')}\n`;
          }
          
        } catch (error) {
          resultBox.className = 'error';
          resultBox.innerText = "❌ 分析失败：" + error.message;
          console.error('分析错误:', error);
        }
      }, 1000);
    }

    // 页面加载时设置默认值
    window.onload = function() {
      // 设置默认出生时间为1990年1月1日12:00
      const defaultDate = new Date('1990-01-01T12:00');
      const dateString = defaultDate.toISOString().slice(0, 16);
      document.getElementById('birth').value = dateString;
    };
  </script>
</body>
</html>
